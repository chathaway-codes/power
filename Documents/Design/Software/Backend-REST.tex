%% Template file for all Software/Hardware modules

% Replace "Name of Module" with the name of this module
\subsection{The \ac{REST} \ac{API}}

\subsubsection{Description}

This module describes the architecture of how the backend will manage features related to providing access to the \ac{REST} \ac{API}.

The \ac{REST} \ac{API} will provide a \filename{urls.py} file, which will provide a handler for all \ac{REST} methods.
These could be achieved by simply using the tastypie \ac{URL}'s, which can be generated by calling \filename{include(api\_v1.urls)} in the urlpatterns object.

\subsubsection{Program Flow}

The \ac{REST} \ac{API} will be activated by the Django chain when a request comes in for the access to the \ac{API}, or when another module directly calls functions in the \ac{API} during their response to a request from the user.

Having each module register itself when the system launches should work, but there may be a problem with things getting registered twice.


\subsubsection{Data Flow}

All data will be returned to the calling client either as a Python dictionary (if called directly from another module), or as \ac{JSON}, \ac{XML}, or \ac{YAML} through a web request (as specified in the query filter using ?format=json).

The \ac{REST} \ac{API} will directly access the database.
Initially, tastypie will be dealing with converting the \ac{HTTP} request to a method on the Django objects.
Django will be generating the \ac{SQL} that actually gets run, and encapsulating objects in Python classes.


\subsubsection{Potential Problems}

At first, we will be using a prepackaged Django module to help provide the \ac{REST} \ac{API}.
This could be problematic because we don't know a lot about the implementation of the \ac{API}, and if there is a problem, tracking it down could be difficult.

The good news is that django-tastypie is well supported by the community, and source code is liberally commented.
It follows Python commenting standards, and should be fairly easy to navigate.
In addition, members of our team have already used tastypie for projects in both work and recreation.

The most problematic bit about using tastypie for the initial run-through is the compatibility problems it has with Backbone.js.
However, the community has developed an addition to Backbone to help deal with this.
It is called Backbone-tastypie.
It is a simple modification to the Backbone sync operations that allows it to communicate with a standard tastypie \ac{REST} \ac{API}.

When the web server is launched, it initialized all modules by calling their \filename{\_\_init\_\_.py} file.
In this file, each module can register themselves with the \ac{API}.
This will allow all modules to be self-contained, which is ideal in that it will allow us to upgrade one module without breaking everything else.

Early experiments indicate that the \filename{\_\_init\_\_.py} file is called twice during the loading of the system.
This could be solved a number of ways, or it might not even be a problem. 
It's very possible the first time the module is loaded it is just being checked for syntax and compiled, then the program is restarting with the compiled files.

\subsubsection{Data Objects}

The REST API will have each module extend the tastypie.resources.ModelResource class. 
They will, as needed, override some methods to allow custom resource handling.
In a later version, we will create a custom pager and implement a way of "expanding" data if we need it.

\begin{table}[H]
  \centering
  \caption{device/init.py}
  \label{code:device/init}
  \input{codes/device/__init__.py}
\end{table}

Table \ref{code:device/init} shows the code that is used by the Device module to init itself and register that module with the raw API.
The raw API will be a direct database mapping, and will be used primarily as a means to test the efficiency of the system in the first prototype.
Currently, there is no authentication or authorization in effect.
These features will be added at a later time.
Please see the tastypie documentation (\url{http://django-tastypie.readthedocs.org/en/latest/}) for information on how this will be done.

\begin{table}[H]
  \centering
  \caption{power data/init.py}
  \label{code:power data/init}
  \input{codes/power_data/__init__.py}
\end{table}

Table \ref{code:power data/init} demonstrates what kind of code would be used to restrict access to the API.
This module does NOT permit POSTing of data to the REST API, since this data will be supplied internally by the power\_data module.